## Default values for Vector
## See Vector helm documentation to learn more:
## https://vector.dev/docs/setup/installation/package-managers/helm/

# role -- Role for this deployment (possible values: Agent, Aggregator, Stateless-Aggregator)
## Ref: https://vector.dev/docs/setup/deployment/roles/
## Each role is created with the following workloads:
## Agent - DaemonSet
## Aggregator - StatefulSet
## Stateless-Aggregator - Deployment
role: "Aggregator"

## Define the Vector image to use
image:
  # image.repository -- Override default registry + name for Vector
  repository: timberio/vector
  # image.pullPolicy -- Vector image pullPolicy
  pullPolicy: IfNotPresent
  # image.pullSecrets -- Agent repository pullSecret (ex: specify docker registry credentials)
  ## Ref: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
  pullSecrets: []
  # image.tag -- Vector image tag to use
  # @default -- Chart's appVersion
  tag: ""

# replicas -- Set the number of Pods to create
## Valid for Aggregator and Stateless-Aggregator
replicas: 1

## Create a Secret resource for Vector to use
secrets:
  # secrets.generic -- Each Key/Value will be added to the Secret's data key
  ## Values should be entered base64 encoded (examples below are "REPLACE_ME" encoded)
  ## NOTE: Don't commit unencrypted secrets to git!
  generic: {}
    # awsAccessKeyId: "UkVQTEFDRV9NRQo="
    # awsSecretAccessKey: "UkVQTEFDRV9NRQo="

## Configure a HorizontalPodAutoscaler for Vector
## Valid for Stateless-Aggregator role
autoscaling:
  # autoscaling.enabled -- Enabled autoscaling for the Stateless-Aggregator
  enabled: false
  # autoscaling.minReplicas -- Minimum replicas for Vector's HPA
  minReplicas: 1
  # autoscaling.maxReplicas -- Maximum replicas for Vector's HPA
  maxReplicas: 10
  # autoscaling.targetCPUUtilizationPercentage -- Target CPU utilization for Vector's HPA
  targetCPUUtilizationPercentage: 80
  # autoscaling.targetMemoryUtilizationPercentage -- (int) Target memory utilization for Vector's HPA
  targetMemoryUtilizationPercentage:
  # autoscaling.customMetric -- Target a custom metric
  customMetric: {}
    #  - type: Pods
    #    pods:
    #      metric:
    #        name: utilization
    #      target:
    #        type: AverageValue
    #        averageValue: 95

rbac:
  # rbac.create -- If true, create and use RBAC resources
  create: true

serviceAccount:
  # serviceAccount.create -- If true, create ServiceAccount
  create: true

  # serviceAccount.name -- The name of the ServiceAccount to use.
  ## If not set and create is true, a name is generated using the fullname template
  name:

# podSecurityContext -- Allows you to overwrite the default PodSecurityContext for Vector
podSecurityContext: {}

# securityContext -- Specify securityContext on the Vector container
securityContext: {}

# env -- Set environment variables in the Vector container
env: []
  # - name: AWS_ACCESS_KEY_ID
  #   valueFrom:
  #     secretKeyRef:
  #       name: vector-aggregator
  #       key: awsAcessKeyId

# resources -- Set Vector resource requests and limits.
resources: {}
  # requests:
  #   cpu: 200m
  #   memory: 256Mi
  # limits:
  #   cpu: 200m
  #   memory: 256Mi

# updateStrategy -- Customize the updateStrategy used to replace Vector Pods
## Also used for the DeploymentStrategy for Stateless-Aggregators
## Valid options are used depending on the chosen role
## Agent (DaemonSetUpdateStrategy): https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec)
## Aggregator (StatefulSetUpdateStrategy): https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec
## Stateless-Aggregator (DeploymentStrategy): https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/deployment-v1/
updateStrategy: {}
#   type: RollingUpdate
#   rollingUpdate:
#     maxUnavailable: 1

# nodeSelector -- Allow Vector to be scheduled on selected nodes
## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
## Ref: https://kubernetes.io/docs/user-guide/node-selection/
nodeSelector: {}

# tolerations -- Allow Vector to schedule on tainted nodes
tolerations: []

# affinity -- Allow Vector to schedule using affinity rules
## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
affinity: {}

## Configuration for Vector's Service
service:
  # service.enabled -- If true, create and use a Service resource
  enabled: true

# customConfig -- Override Vector's default configs, if used **all** options need to be specified
## This section supports using helm templates to populate dynamic values
## Ref: https://vector.dev/docs/reference/configuration/
customConfig: {}

## Configuration for Vector's data persistence
persistence:
  # persistence.enabled -- If true, create and use PersistentVolumeClaims
  enabled: false
  # persistence.existingClaim -- Name of an existing PersistentVolumeClaim to use
  ## Valid for Aggregator role
  existingClaim: ""
  # persistence.storageClassName -- Specifies the storageClassName for PersistentVolumeClaims
  ## Valid for Aggregator role
  # storageClassName: default

  # persistence.accessModes -- Specifies the accessModes for PersistentVolumeClaims
  ## Valid for Aggregator role
  accessModes:
    - ReadWriteOnce
  # persistence.size -- Specifies the size of PersistentVolumeClaims
  ## Valid for Aggregator role
  size: 10Gi
  # persistence.finalizers -- Specifies the finalizers of PersistentVolumeClaims
  ## Valid for Aggregator role
  finalizers:
    - kubernetes.io/pvc-protection
  # persistence.selectors -- Specifies the selectors for PersistentVolumeClaims
  ## Valid for Aggregator role
  selectors: {}

  hostPath:
    # persistence.hostPath.path -- Override path used for hostPath persistence
    ## Valid for Agent role, persistence always used for Agent role
    path: "/var/lib/vector"

# livenessProbe -- Override default liveness probe settings
## Requires Vector's API to be enabled
livenessProbe: {}
  # httpGet:
  #   path: /health
  #   port: api

# readinessProbe -- Override default readiness probe settings, if customConfig is used require customConfig.api.enabled true
## Requires Vector's API to be enabled
readinessProbe: {}
  # httpGet:
  #   path: /health
  #   port: api

## Optional built-in HAProxy load balancer
haproxy:
  # haproxy.enabled -- If true, create a HAProxy load balancer
  enabled: false

  ## Define the HAProxy image to use
  image:
    # haproxy.image.repository -- Override default registry + name for HAProxy
    repository: haproxytech/haproxy-alpine
    # haproxy.image.pullPolicy -- HAProxy image pullPolicy
    pullPolicy: IfNotPresent
    # haproxy.image.pullSecrets -- HAProxy repository pullSecret (ex: specify docker registry credentials)
    ## Ref: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []
    # haproxy.image.tag -- HAProxy image tag to use
    tag: "2.4.4"

  # haproxy.replicas -- Set the number of HAProxy Pods to create
  replicas: 1

  serviceAccount:
    # haproxy.serviceAccount.create -- If true, create a HAProxy ServiceAccount
    create: true

    # haproxy.serviceAccount.name -- The name of the HAProxy ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    name:

  # haproxy.terminationGracePeriodSeconds -- Override HAProxy's terminationGracePeriodSeconds
  terminationGracePeriodSeconds: 60

  # haproxy.podAnnotations -- Set annotations on HAProxy Pods
  podAnnotations: {}

  # haproxy.podSecurityContext -- Allows you to overwrite the default PodSecurityContext for HAProxy
  podSecurityContext: {}
    # fsGroup: 2000

  # haproxy.securityContext -- Specify securityContext on the HAProxy container
  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  ## HAProxy's Service configuration
  service:
    # haproxy.service.type -- Set type of HAProxy's Service
    type: ClusterIP

  # haproxy.customConfig -- Override HAProxy's default configs, if used **all** options need to be specified
  ## The chart will parse sources and sinks from customConfig to generate HAProxy config, this generated config
  ## can be overwritten with haproxy.customConfig
  ## This section supports using helm templates to populate dynamic values
  customConfig: ""

  ## Configure a HorizontalPodAutoscaler for HAProxy
  autoscaling:
    # haproxy.autoscaling.enabled -- Enabled autoscaling for HAProxy
    enabled: false
    # haproxy.autoscaling.minReplicas -- Minimum replicas for HAProxy's HPA
    minReplicas: 1
    # haproxy.autoscaling.maxReplicas -- Maximum replicas for HAProxy's HPA
    maxReplicas: 10
    # haproxy.autoscaling.targetCPUUtilizationPercentage -- Target CPU utilization for HAProxy's HPA
    targetCPUUtilizationPercentage: 80
    # haproxy.autoscaling.targetMemoryUtilizationPercentage -- (int) Target memory utilization for HAProxy's HPA
    targetMemoryUtilizationPercentage:
    # haproxy.autoscaling.customMetric -- Target a custom metric
    customMetric: {}
      #  - type: Pods
      #    pods:
      #      metric:
      #        name: utilization
      #      target:
      #        type: AverageValue
      #        averageValue: 95

  # haproxy.resources -- Set HAProxy resource requests and limits.
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # haproxy.nodeSelector -- Allow HAProxy to be scheduled on selected nodes
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  nodeSelector: {}

  # haproxy.tolerations -- Allow HAProxy to schedule on tainted nodes
  tolerations: []

  # haproxy.affinity -- Allow HAProxy to schedule using affinity rules
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}
